#include "Tools.h"

// various tools used to interact with process objects
namespace Process
{
	// structure that contains handle information
	typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
	{
		ULONG ProcessId;
		BYTE ObjectTypeNumber;
		BYTE Flags;
		USHORT Handle;
		PVOID Object;
		ACCESS_MASK GrantedAccess;
	} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

	// structure that cointains the array of handles returned from the system query
	typedef struct _SYSTEM_HANDLE_INFORMATION
	{
		ULONG HandleCount;
		SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
	} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

	// returns the length of a remote string
	DWORD GetRemoteStringLength(HANDLE hProcess, PVOID pString)
	{
		// stores the character
		CHAR Character;
		// defines the string index
		DWORD dwIndex = 0;
		// while the character is not zero
		do
		{
			// reads a character
			if (!ReadProcessMemory(hProcess, (PBYTE)pString + dwIndex, &Character, sizeof(CHAR), NULL))
				// function failed
				return NULL;
			// increments the index
			dwIndex += 1;
		} while (Character != 0);
		// returns the string length
		return dwIndex;
	}

	// wrapper for iswow64process
	BOOL IsProcess32(HANDLE hProcess, PBOOL Wow64Process)
	{
		// checks if the function exists
		if (GetProcAddress(GetModuleHandleA("Kernel32.dll"), "IsWow64Process"))
			// checks the if the target process is running under wow64
			if (IsWow64Process(hProcess, Wow64Process))
				// function succeeded
				return TRUE;
		// returns false
		return FALSE;
	}

	// returns the process id for the given image name
	DWORD FindProcess(LPCSTR lpImageName)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		// validates the handle
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			// stores the process information
			PROCESSENTRY32 ProcessInfo;
			// sets the structure size
			ProcessInfo.dwSize = sizeof(PROCESSENTRY32);
			// gets the first process
			if (Process32First(hSnapshot, &ProcessInfo))
			{
				// gets the information of the next process
				do
				{
					// checks the process name
					if (_stricmp(ProcessInfo.szExeFile, lpImageName) == 0)
					{
						// returns the pid
						return ProcessInfo.th32ProcessID;
					}
				} while (Process32Next(hSnapshot, &ProcessInfo));
			}
		}
		// else we return null
		return NULL;
	}

	// returns the eprocess address for the process id given
	// using the ntquerysysteminformation eprocess address leak
	PVOID GetObjectAddress(DWORD dwProcessId)
	{
		// opens a handle to the process
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessId);
		// validates the handle
		if (hProcess != INVALID_HANDLE_VALUE)
		{
			// allocates a buffer to store the retrieved handle information
			PSYSTEM_HANDLE_INFORMATION pHandles = (PSYSTEM_HANDLE_INFORMATION)malloc(10000);
			// stores the return length
			ULONG uLength = 10000;
			// zeros out the buffer
			ZeroMemory(pHandles, 10000);
			// queries all the handles on the system
			while (NtQuerySystemInformation(SystemHandleInformation, pHandles, uLength, &uLength) == STATUS_INFO_LENGTH_MISMATCH)
			{
				// reallocates the buffer to the correct size
				pHandles = (PSYSTEM_HANDLE_INFORMATION)realloc(pHandles, uLength);
				// zeros out the buffer
				ZeroMemory(pHandles, uLength);
			}
			// iterates through system handles
			for (int i = 0; i < pHandles->HandleCount; i++)
			{
				// checks the process id and the handle value
				if (pHandles->Handles[i].ProcessId == GetCurrentProcessId() && pHandles->Handles[i].Handle == (USHORT)hProcess)
				{
					// closes the handle
					CloseHandle(hProcess);
					// returns the address of the eprocess object
					return pHandles->Handles[i].Object;
				}
			}
			// closes the handle
			CloseHandle(hProcess);
		}
		// else we return null
		return NULL;
	}

	// sets the handle's granted access value
	BOOL SetHandleAccess(HANDLE hProcess, DWORD DesiredAccess)
	{
		// make driver static functions
		// creates our driver object
		Driver KernelDriver = Driver();
		// loads the kernel driver
		if (KernelDriver.LoadDriver())
		{
			// elevates the handle with the kernel driver
			if (KernelDriver.SetHandleAccess(GetCurrentProcessId(), hProcess, DesiredAccess))
			{
				// unloads the kernel driver
				if (KernelDriver.UnloadDriver())
				{
					// we return true
					return TRUE;
				}
			}
			// unloads the kernel driver
			KernelDriver.UnloadDriver();
		}
		// else we return false
		return FALSE;
	}

	// opens a handle to the given process via a driver
	HANDLE GetProcessHandle(DWORD dwProcessId, DWORD dwDesiredAccess)
	{
		// opens a handle to the process
		HANDLE hProcess = OpenProcess(dwDesiredAccess, FALSE, dwProcessId);
		// validates the handle
		if (hProcess != INVALID_HANDLE_VALUE)
			// check if the handle value is correct
			// if not elevate
			// do this!
			// elevates the created handle
			if (SetHandleAccess(hProcess, dwDesiredAccess))
				// returns the handle
				return hProcess;
		// function failed
		return NULL;
	}
}