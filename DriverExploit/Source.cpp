#include <iostream>
#include "Tools.h"

using namespace std;

// ___  ____     _        _              
// |  \/  (_)   | |      | |             
// | .  . |_ ___| |_ __ _| | _____ _ __  
// | |\/| | / __| __/ _` | |/ / _ \ '_ \ 
// | |  | | \__ \ || (_| |   <  __/ | | |
// \_|  |_/_|___/\__\__,_|_|\_\___|_| |_|
// a universal user-friendly miscreated hack
// created by hunter24957

// TODO
// We can now obtain a PROCESS_ALL_ACCESS handle to the process
// all that's left to do in manually map our dll hack and resolve any dependencies
// also watch out for the api dlls and check if the process already has the dll loaded
// if so, we can use that one to resolve any dependencies

// don't close a handle after an if statement fail, because they might already be closed and could crash the program, figure out something different

// CopyModuleToLocalAddress space then parse export table?? can get module size
// static load dll function
// manual map loadremotelibrary
// parse export table of externel dlls
// add more tables to handl parsing
// add support for targeting 32 bit programs
// add 32 bit virtual to physical address translation

// load the dll into memory
// write the sections to the process
// write the headers to the process
// rebase the image
// resolve any imports
// if the dll is already in the process
// - get the base address and resolve imports like normal but using that base
// if the dll is a win api dll
// - find what dll it links to
// resolve the functions
// goto step 1
// resolve TLS (Thread Local Storage)?

// consider wrting the driver into the system drivers directory and not deleting it? am I crazy?!

// validate the dll being mapped

// the main program entry
int main(int argc, char *argv[])
{
	// validates the arg count
	if (argc > 2)
	{
		// gets the pid of the process
		if (DWORD ProcessId = Process::FindProcess(argv[1]))
		{
			// notifies user
			cout << "[+] Found the process" << endl;
			// opens a handle to the process
			if (HANDLE hProcess = Process::GetProcessHandle(ProcessId, PROCESS_ALL_ACCESS))
			{
				// notifies user
				cout << "[+] Opened a handle to the process" << endl;
				// MANUAL MAP DLL
				// remotely loads a library into the process
				if (Module::LoadRemoteLibrary(hProcess, argv[2]))
				{
					// notifies user
					cout << "[+] Successfully loaded the library into the process" << endl;
				}
				else
				{
					// notifies user
					cout << "[-] Could not load the library into the process" << endl;
				}
				// closes the handle
				if (CloseHandle(hProcess))
				{
					// notifies user
					cout << "[+] Closed the process handle" << endl;
				}
				else
				{
					// notifies user
					cout << "[-] Could not close the process handle" << endl;
				}
			}
			else
			{
				// notifies user
				cout << "[-] Could not open a handle to the process" << endl;
			}
		}
		else
		{
			// notifies user
			cout << "[-] Process not found" << endl;
		}
	}
	else
	{
		// notifies user
		cout << "[-] Invalid arguments" << endl;
	}
	// waits to exit
	cin.get();
	// returns to the kernel
	return 0;
}

// wow64 modules listing
// load dlls from SysWOW64 folder
// parser with NT_HEADERS32